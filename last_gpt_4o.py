# -*- coding: utf-8 -*-
"""LAST GPT 4o

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vP3uYiYlIqXjZCeujs53L4QKwDUYc1kB
"""

!pip install openai serpapi requests beautifulsoup4

!pip install --upgrade serpapi

import serpapi
print(serpapi.__file__)

import os

# ğŸ” API key's
os.environ["SERPAPI_API_KEY"] = "7efe29a37e5bff4391ab161a83fce6ceca0c4d248ba3ea1d3f1d58694964b672"
os.environ["AZURE_OPENAI_API_KEY"] = "Fs2m23tC10YzLZkVgxDQqWpZWgCGe2f9170RGWq7zSejWPqEG4jqJQQJ99BFACHYHv6XJ3w3AAAAACOGpwCo"

# Azure endpoint and model info
AZURE_OPENAI_ENDPOINT = "https://canli-mc0ii7d5-eastus2.openai.azure.com/"
AZURE_OPENAI_DEPLOYMENT = "gpt-4o"  # model name

import os
import requests

def get_google_links_direct(query, num_results=3):
    api_key = os.getenv("SERPAPI_API_KEY")
    params = {
        "engine": "google",
        "q": query,
        "api_key": api_key,
    }
    response = requests.get("https://serpapi.com/search", params=params)
    data = response.json()
    results = data.get("organic_results", [])
    links = [r['link'] for r in results[:num_results]]
    return links

# ğŸ” 1. Tender search
tender_query = "security camera procurement tender site:europa.eu"
tender_links = get_google_links_direct(tender_query)
print("ğŸ”— Tender links:", tender_links)

# ğŸ›’ 2. Supplier search
supplier_query = "security camera supplier Europe price range site:.com OR site:.co.uk"
supplier_links = get_google_links_direct(supplier_query)
print("ğŸ›’ Supplier Links:", supplier_links)

# ğŸ”„ 3. Merge All
all_links = tender_links + supplier_links
print("ğŸ”— All links:", all_links)

from openai import AzureOpenAI
import os, requests, bs4

def fetch_page_text(url):
    try:
        res = requests.get(url, timeout=10)
        soup = bs4.BeautifulSoup(res.text, "html.parser")
        return soup.get_text(separator=" ", strip=True)
    except Exception as e:
        print("Fetch error:", e)
        return ""

tender_texts   = [fetch_page_text(u) for u in tender_links]
supplier_texts = [fetch_page_text(u) for u in supplier_links]

from openai import AzureOpenAI
import os

client = AzureOpenAI(
    api_key=os.getenv("AZURE_OPENAI_API_KEY"),
    api_version="2024-05-01-preview",
    azure_endpoint=AZURE_OPENAI_ENDPOINT
)

tender_prompt = f"""
You are a public tender expert for Dublin City Council.

Below are documents from security camera public tenders:
{tender_texts[0][:1500]}
{tender_texts[1][:1500] if len(tender_texts) > 1 else ''}

1. Summarize the most common **technical and legal requirements**.
2. Generate 5 clarification questions that a city official should answer before drafting a new tender.
"""

supplier_prompt = f"""
You are a market analyst advising a municipality about camera system purchases.

Below are supplier websites or documents:
{supplier_texts[0][:1500]}
{supplier_texts[1][:1500] if len(supplier_texts) > 1 else ''}

1. Summarize the most common **features, pricing, and delivery models** offered in the market.
2. Generate 5 clarifying questions to help compare or choose between supplier options.
"""

tender_resp = client.chat.completions.create(
    model=AZURE_OPENAI_DEPLOYMENT,
    messages=[{"role": "user", "content": tender_prompt}]
)

supplier_resp = client.chat.completions.create(
    model=AZURE_OPENAI_DEPLOYMENT,
    messages=[{"role": "user", "content": supplier_prompt}]
)

print("ğŸ“‘ Tender Summary + Questions:\n")
print(tender_resp.choices[0].message.content)

print("\nğŸ›’ TedarikÃ§i Ã–zeti + Questions:\n")
print(supplier_resp.choices[0].message.content)

# -----------------------------
#  EXAMPLE ANSWERS
# -----------------------------
user_answers = """
TENDER-SIDE CLARIFICATION ANSWERS
1. Purpose & Scope
   â€¢ Main goals: crime prevention around parks and municipal buildings, plus traffic-flow monitoring at busy intersections.
   â€¢ Coverage: 10 public parks, 5 key intersections, 3 municipal buildings (â‰ˆ60 cameras total).

2. Data & Privacy
   â€¢ Footage kept 30 days, encrypted at rest and in transit.
   â€¢ GDPR Article 35 DPIA will be completed; local signage required under DCC by-laws.

3. Integration & Scalability
   â€¢ Must integrate with existing 25 analogue-to-IP converted cameras and the cityâ€™s traffic-control VMS.
   â€¢ Scalable to 100 additional devices within 5 years.

4. Performance & Analytics
   â€¢ Required uptime 99.5 % monthly; SLA response â‰¤4 h, fix â‰¤24 h.
   â€¢ Mandatory analytics: motion detection + licence-plate recognition (LPR).
   â€¢ Facial recognition optional.

5. Environment & Budget
   â€¢ Energy-efficiency class A or equivalent; low-power PoE preferred.
   â€¢ Budget ceiling â‚¬120 000 (ex-VAT). Vendors may propose cost-saving options.

SUPPLIER-SIDE CLARIFICATION ANSWERS
1. Durability / Warranty
   â€¢ Outdoor lifespan â‰¥7 years; baseline 3-year full-replacement warranty, extendable to 5 years.

2. Integration & Firmware
   â€¢ ONVIF Profile S + RTSP; open SDK; OTA firmware upgrades required.

3. Power / Connectivity
   â€¢ Solar-powered units include battery backup â‰¥72 h; data plan budget 5 GB per camera / month.

4. Installation & Maintenance
   â€¢ Turn-key install by supplier; training for city technicians.
   â€¢ Annual maintenance cost cap â‚¬50 per camera.

5. Scalability & Stock
   â€¢ Volume discount 10 % for orders >50 units.
   â€¢ Supplier guarantees part availability for 5 years.
"""

# ---------------------------------------------
#  GPT-4o PROMPT for writing R&S draft
# ---------------------------------------------
draft_prompt = f"""
You are a public procurement expert working at Dublin City Council.
You have conducted a market analysis on municipal surveillance camera systems and identified both common supplier offerings and typical tender requirements.

Now write a **complete and professional 'Requirements and Specifications' section** for a new security camera tender.
Structure it just like the real Irish tender documents provided before. Include the following:

- A short introduction / background
- Detailed technical requirements in bullet points or tables (e.g., resolution, night vision, weatherproofing, storage, analytics)
- Legal and compliance requirements (especially GDPR and EU procurement directives)
- Installation and maintenance responsibilities
- Service levels (SLAs), warranties, and support
- Any environmental or sustainability standards
- Pricing and contractual expectations

Make sure the structure and language matches what is commonly used in Irish public sector tenders.
Do not generate questions. Generate a final tender section text.
Length: at least 700â€“1000 words.


--- USER NOTES ---
{user_answers}
"""

draft_resp = client.chat.completions.create(
    model="gpt-4o",
    messages=[
        {"role": "system", "content": "You are a public procurement expert at Dublin City Council, drafting professional tender documentation."},
        {"role": "user", "content": draft_prompt}
    ],
    temperature=0.2,
    max_tokens=3000,
    top_p=1,
    frequency_penalty=0,
    presence_penalty=0
)

print("ğŸ“„ FINAL REQUIREMENTS & SPECIFICATIONS\n")
print(draft_resp.choices[0].message.content)

from google.colab import files
uploaded = files.upload()  # choose PDF's

!pip install PyPDF2

from PyPDF2 import PdfReader

tender_texts = []
for filename in uploaded.keys():
    reader = PdfReader(filename)
    text = ""
    for page in reader.pages:
        page_text = page.extract_text()
        if page_text:
            text += page_text
    tender_texts.append(text)

draft_prompt = f"""
You are a public procurement expert working at Dublin City Council.

Here are real tender excerpts from previous Irish municipal projects:
{tender_texts[0][:1500]}
{tender_texts[1][:1500] if len(tender_texts) > 1 else ''}

You have also conducted a market analysis and collected key answers:

--- USER CLARIFICATIONS ---
{user_answers}

Now write a **comprehensive and professional 'Requirements and Specifications' section** for a new security camera tender.

Structure it similarly to the real Irish tender documents above.
Include all key elements:
- Background and purpose
- Technical specifications (preferably in table or bullet format)
- Legal and compliance (GDPR, CE, ISO, etc.)
- Installation & maintenance
- SLAs, warranty, support
- Environmental standards
- Budget & contractual terms

Style must be formal, clear, and aligned with EU procurement documentation.
Do not generate questions â€” only the full section text, 800â€“1000 words.
"""

response = client.chat.completions.create(
    model="gpt-4o",
    messages=[
        {"role": "system", "content": "You are a tender documentation expert in a public institution."},
        {"role": "user", "content": draft_prompt}
    ],
    temperature=0.2,
    max_tokens=3500
)

print("ğŸ“„ FINAL R&S SECTION:\n")
print(response.choices[0].message.content)

draft_prompt = f"""
You are a senior tender documentation officer working at Dublin City Council.
You are responsible for writing detailed and high-standard tender documents in accordance with Irish and EU procurement norms.

Below are authentic excerpts from previously published public tenders related to security technologies:
{tender_texts[0][:1500]}
{tender_texts[1][:1500] if len(tender_texts) > 1 else ''}

You have also received internal notes clarifying specific needs and expectations for this procurement:
--- USER CLARIFICATIONS ---
{user_answers}

Your task is to write an extremely comprehensive **"Requirements and Specifications"** section for a new public tender to procure security cameras and video management infrastructure.

ğŸŸ¢ Your response MUST:
- Be at least **1500 words** in length.
- Fully reflect the **structure, level of detail, language style**, and **subsection formatting** used in Irish public tenders (like the examples above).
- Include multiple tables (e.g., camera specs, VMS features, installation steps, SLAs, etc.).
- Use **bullet points**, **numbered sections**, **section headers**, and **clear formatting**.
- Explicitly mention relevant Irish/EU laws (e.g., GDPR, CE Marking, ISO27001, 2014/24/EU).
- Present both **mandatory** and **desirable** features, clearly marked.
- Emphasize sustainability, accessibility, cybersecurity, training, and documentation expectations.
- Cover full **lifecycle**: procurement, delivery, installation, support, exit/transition.
- **Table-layout rules:** any table must fit on an A4 page in portrait orientation with 2 cm margins;
  â€¢ limit to **max 3-4 columns**, each â‰¤ 6 cm wide.
  â€¢ If a cellâ€™s text would overflow, replace it with a superscript footnote symbol (e.g. Â¹) and put the full explanation in a â€œTable Notesâ€ paragraph directly under the table.
  â€¢ Split very wide tables into multiple stacked tables (e.g. break after the â€œVerification Methodâ€ column).
- **Column & text limits:** every table may contain **max 4 columns** and **max 30 characters per cell** (including spaces).
  â€¢ Overflow â†’ superscript note mark, explanation in â€œTable Notesâ€.
  â€¢ Split if still too wide.
  â€¢ **Do NOT reuse the sample column headings; choose headings appropriate to each table.**
  Example layout (for structure only, not wording):
  | A | B | C | DÂ¹ |
For the â€œMin. Numerical Valueâ€ column, always state a concrete figure and unit (e.g., â€œ0.01 Luxâ€, â€œIP66â€); **do not use Yes/No here**â€”if the feature is binary, move Yes/No to a separate â€œSupported?â€ column instead.
- In every table, **do NOT leave any cell blank**.
  â€¢ If the value is the same as the row above, repeat it verbatim (e.g., write â€œPlatformâ€ again) or use the ditto symbol â€œã€ƒâ€.
  â€¢ Keep the column order fixed so that each row has exactly the same number of cells.

- Insert Word-friendly formatting hints (e.g. â€œ|---|â€ rows exactly match the final column count) so the table can be pasted without breaking.

âš ï¸ Do not generate any questions. Only provide the full Requirements and Specifications section, formatted as it would appear in a formal public tender.

Start your section now.
"""

response = client.chat.completions.create(
    model="gpt-4o",
    messages=[
        {"role": "system", "content": "You are a senior public procurement officer writing long, formal tender documents for Irish municipalities."},
        {"role": "user", "content": draft_prompt}
    ],
    temperature=0.2,
    max_tokens=4096  # maximum allowed
)

print("ğŸ“„ FINAL LONG R&S SECTION:\n")
print(response.choices[0].message.content)

pip install python-docx

!pip -q install python-docx

import re
from docx import Document

def extract_markdown_tables(text: str):
    """
    Captures Markdown formatted tables ( | col | col | col | ... ),
 turns each table into a list of [ [row1cells], [row2cells], ... ].
    """
    #
    table_blocks = re.findall(r"(?:\|[^\n]+\n)+", text)
    tables = []
    for block in table_blocks:
        lines = [ln.strip() for ln in block.splitlines() if ln.strip()]
        # |-----|----|
        lines = [ln for ln in lines if not re.match(r"^\|[-\s|]+$", ln)]
        rows = [[cell.strip() for cell in ln.strip("|").split("|")] for ln in lines]
        if rows:
            tables.append(rows)
    return tables

def write_word_with_tables(full_text: str, filename: str = "R&S_Output.docx"):
    """
    It converts the tables in the GPT output into real Word tables and saves them as .docx.
    Text fragments are inserted as paragraphs between tables.
    """
    doc = Document()

    #
    table_pattern = r"(?:\|[^\n]+\n)+"
    text_parts = re.split(table_pattern, full_text)
    tables = extract_markdown_tables(full_text)

    for idx, part in enumerate(text_parts):
        if part.strip():
            doc.add_paragraph(part.strip())

        if idx < len(tables):
            data = tables[idx]
            tbl = doc.add_table(rows=1, cols=len(data[0]))
            for j, hdr in enumerate(data[0]):
                tbl.rows[0].cells[j].text = hdr

            for row in data[1:]:
                cells = tbl.add_row().cells
                for j, val in enumerate(row):
                    cells[j].text = val

            doc.add_paragraph("")

    doc.save(filename)
    print(f"âœ… Word file saved: {filename}")

# 2) GPT output
output_text = response.choices[0].message.content   # <- your output

# 3) send text to word file
write_word_with_tables(output_text, "Security_Camera_R&S.docx")

from google.colab import files
files.download("Security_Camera_R&S.docx")

!pip -q install python-docx

import re
from docx import Document

def md_table_to_docx(md: str, outfile="R&S.docx"):
    doc = Document()
    pattern = r"(?:\|[^\n]+\n)+"
    parts = re.split(pattern, md)              # metin-tablo-metinâ€¦
    tables = re.findall(pattern, md)

    # pipe tablodaki kalÄ±n (**) iÅŸaretlerini temizleyip hÃ¼creye yazacaÄŸÄ±z
    def clean(cell): return re.sub(r"\*\*(.*?)\*\*", r"\1", cell).strip()

    for i, part in enumerate(parts):
        if part.strip():
            doc.add_paragraph(part.strip())
        if i < len(tables):
            rows = [
                [clean(c) for c in ln.strip().strip("|").split("|")]
                for ln in tables[i].splitlines()
                if ln.strip() and not re.match(r"^\|[-\s|]+$", ln)
            ]
            tbl = doc.add_table(rows=1, cols=len(rows[0]))
            for j, h in enumerate(rows[0]): tbl.rows[0].cells[j].text = h
            for r in rows[1:]:
                cells = tbl.add_row().cells
                for j, val in enumerate(r): cells[j].text = val
            doc.add_paragraph()

    doc.save(outfile)
    print("âœ… Saved:", outfile)

# --- kullan:
output_text = response.choices[0].message.content
md_table_to_docx(output_text, "Security_Camera_R&S.docx")

from google.colab import files; files.download("Security_Camera_R&S.docx")

import time, statistics, pandas as pd
from openai import AzureOpenAI

# â–¶ï¸ Ortam deÄŸiÅŸkeni veya doÄŸrudan parametre
client = AzureOpenAI(
    api_key="Fs2m23tC10YzLZkVgxDQqWpZWgCGe2f9170RGWq7zSejWPqEG4jqJQQJ99BFACHYHv6XJ3w3AAAAACOGpwCo",
    azure_endpoint="https://canli-mc0ii7d5-eastus2.openai.azure.com/",
    api_version="2024-05-01-preview"
)

PROMPT = "Explain in exactly 80 English words what a municipal security camera tender must include."

# Hangi deploymentâ€™larÄ± test edeceksin?
DEPLOYMENTS = {
    "gpt-4o": "gpt4o-deploy",            # label : deployment name
    # "gpt-35-turbo": "gpt35-deploy",    # istersen ekle
}

N_RUNS = 3

results = []
for label, deploy_name in DEPLOYMENTS.items():
    latencies, tokens = [], []
    print(f"\nâ±  Testing {label} â€¦")

    for i in range(N_RUNS):
        t0 = time.perf_counter()
        resp = client.chat.completions.create(
            model= "gpt-4o" ,                    # ğŸ”‘ Deployment adÄ±
            messages=[{"role": "user", "content": PROMPT}],
            temperature=0.2
        )
        elapsed = time.perf_counter() - t0
        latencies.append(elapsed)
        tokens.append(resp.usage.total_tokens)    # Azure response da token bilgisi verir
        print(f"  run {i+1}: {elapsed:.2f}s, tokens={tokens[-1]}")

    results.append({
        "Deployment": label,
        "Avg latency (s)": f"{statistics.mean(latencies):.2f}",
        "Std dev (s)": f"{statistics.stdev(latencies):.2f}" if N_RUNS > 1 else "0",
        "Avg tokens": f"{statistics.mean(tokens):.0f}"
    })

pd.DataFrame(results)



